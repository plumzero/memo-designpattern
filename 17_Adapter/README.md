
要实现的**功能相同，但接口不同时**，适配器模式可以作为新旧接口之间的桥梁作用。

适配器模式有两种:
- 对象适配器模式(使用委托的适配器)
- 类适配器模式(使用继承的适配器)

对象适配器模式可以用于对接口的适配。很多开源库在使用时，会编译成动态库及一些头文件，这些头文件包含了众多供开发者使用的关于这些动态库的接口。开发者通过调用这些接口来完成自己需要的功能，即使后续动态库功能有调整(例如为优化而使版本升级)，只要调用的接口不变，那么我们的程序就不需要再改动。这就是接口适配。

[一种接口文件示例](interface.h)

在上面的接口文件中，开发者并不清楚 node_handlers_ 和 topics_manager_ 这两个委托变量的细节实现，但因为进行了前向声明，所以编译器可以通过。

当某个类需要使用其他类的功能时，也可以将其他类作为这个类的成员进行委托，这也是对象适配器模式的一种使用方式。

类适配器模式通过继承来实现，而且用作继承的父类一般是具体类，因为只有这样才能达成对功能的适配(抽象类不实现具体功能)。

另外，适配也适用于模板，比如 STL 中 std::stack, std::queue 等就是标准容器的容器适配器。

适配器模式和窗口模式看起来很像，不过窗口模式更像是将许多并不直接相关的功能进行组合，而适配器模式更着重于对功能的继承。

[对象适配器模式示例](delegate.cpp)

[类适配器模式示例](inherit.cpp)

在类适配器模式示例中，为了更好的封装，将用于继承的父类中的方法定义为 protected 访问。
