
实现观察者模式主要用到了 C++ 委托和继承方面的内容。

在 Observer 模式中，当观察对象的状态发生变化时，会通知给观察者。 Observer 模式适用于根据对象进行相应处理的场景。

为实现一致性，抽象(接口)化观察者 Observer 。为了被观察对象的可供扩展，抽象化被观察对象 Subject 。

在这里定义并实现了两个观察者，它们作为子类由基类派生。Subject 子类对象将两个观察者对象通过 attach 方法加入到自己的维护 list，当被观察对象需要通知观察者对象时，就可以通过执行 execute 方法来遍历 list 中的每个观察者对象，后者将调用 update 方法对被观察对象进行处理。

[程序示例](observer.h)

注意:
- 被观察对象中可能有多个 Observer 角色，在上述示例程序中，先添加到 list 中的 Observer 会先执行观察。在设计具体的观察者(ConcreteObserver)角色时，需要注意这些观察者的观察方法(这里是 update)的调用顺序，不能因为观察方法的调用顺序发生改变而产生问题。
- 要注意观察者的行为对观察对象可能造成的影响(如改写观察对象)。
- 虽然名为观察者，但实际上观察者角色并非主动地去观察，而是被动地接受来自被观察对象角色的通知。因此，观察者模式也被称为 **Publish-Subscribe(发布-订阅)模式**。
