
通过访问者模式，一定程度上可以将数据结构与处理分离开来。

以[这个简单示例程序](simple.cpp)为例，Major 和 Minor 如果想要使用 Patch 的功能，可以使用继承或复合来实现。不过使用继承在这里不适合语义，而且管理不太方便(例如如果要改为使用 Patch2 的功能时)。

如果不想冒然因为一个功能就增加一个复合成员变量，这里就可以使用访问者模式来委托其他类对象实现自身的功能。

访问者模式也可以与 virtual 一起使用，示例如下。

将目录条目打印出来。目录条目分为两种: 文件和目录，是两种不同的数据结构，现在要分开对它们进行处理(这里是打印两种目录条目)。

先定义关于数据结构(File 和 Directory)的处理类，即访问者类(Visitor)，其重载了针对不同数据结构处理的不同方法，这些方法后续会在相应的数据结构类中定义的方法中调用执行。

之后定义目录条目的基类 Entry ，并定义处理不同目录条目(数据结构)的方法 accept ，该方法交由子类实现，accept 方法中的实现会委托给在访问者类中定义的相应方法中实现。

[示例程序](realize.cpp)

从上例中可以看出，数据结构与打印处理分开了。不过在上面这个示例中，完全可以在基类 Entry 中定义一个虚方法，交由子类实现，比使用访问者模式书写简单且容易理解。

不过在子类继承较深的时候，如果在顶层基类定义这样的一个打印方法，那么可能需要在层层子类中都要进行对应的实现(可能在某些子类中实现这样的方法并没有什么意义)，那样就麻烦了。这个时候不妨考虑使用访问者模式(但是细细想来，也可以在上层父类中定义一个虚方法)。

不管怎样，在后续维护中如果要添加新功能的话，使用访问者模式可以有效地与已有的代码进行分离，减少对已有代码的修改，不失为一个好办法。
