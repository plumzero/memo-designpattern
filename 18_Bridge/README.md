
### 背景

先从类的两种层次结构说起...

1. 类的功能层次结构

假设现在有一个类 Something ，当我们想在 Something 中增加新功能时(增加一个具体方法)，会编写一个 Something 类的子类(派生类)，如 SomethingGood 类，这样就构成了一个类层次结构。
```s
  Something
    |-- SomethingGood
```
像上面这种层次结构称为"**类的功能层次结构**"，它具有以下特征:
- 父类具有基本功能
- 在子类中增加新的功能

2. 类的实现层次结构

抽象类声明了一些抽象方法，定义了接口(API)，然后子类负责去实现这些抽象方法。父类的任务是通过声明抽象方法的方式定义接口(API)，而子类的任务是实现抽象方法。比如抽象类 AbstractClass 中定义了接口，子类 ConcreteClass 实现了抽象类中定义的方法，它们之间就构成了一个层次结构:
```s
  AbstractClass
    |-- ConcreteClass
```
像上面这种层次结构称为"**类的实现层次结构**"，它具有以下特征:
- 父类通过声明抽象方法来定义接口
- 子类通过实现具体方法来实现接口

3. 类的层次结构的混杂与分离

了解了类的两种层次结构后，那么当我们想要编写子类时，就需要先确认自己的意图: 是要增加功能呢？还是要增加实现呢？

当类的实现只有一层时，功能层次结构与实现层次结构混杂在一个层次结构中。这样很容易使类的层次结构变得复杂。

因此，我们需要将"类的功能层次结构"与"类的实现层次结构"分离为两个独立的类层次结构。当然，如果只是简单地将它们分开，两者之间必然会缺少联系。所以我们还需要在它们之间搭建一座桥梁。这就要用到桥接(Bridge)模式。

### 说明

设计模式的"桥接"不是"桥接"之后，两端可以平等的交流数据，而是架好一座从活动端(上层)到不动端(底层)的桥梁，这样活动端就可以访问不动端。

一般来说，类的实现层次结构是从整体的功能实现作把控，而类的功能层次结构在整体功能实现基础上进行具体的修缮。所以通常将类的功能层次视为活动端，将类的实现作为不动端。

用户对程序的调用及维护工作量也主要体现在上层主动端，即类的功能层次结构。

[示例程序](realize.cpp)

[功能与数据之间的桥接示例](realize2.cpp)

可能是我理解不够，个人感觉桥接模式有点画蛇添足的味道。不过在一些开源项目(如 restbed)和 STL 的一些标准容器中均有使用到，可能这种模式更适合学院派吧。
