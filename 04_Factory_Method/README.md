
在 Factory Method 模式中，父类决定实例的生成方式，但并不决定所要生成的具体的类，具体的处理全部交给子类负责。这样就可以将生成实例的框架(framework)和实际负责生成实例的类解耦。

在编写服务时，要定义和处理不同种类的消息，为此可以为每种消息实现一个处理方法。消息与方法一一对应。针对以这个场景作为示例来说明工厂模式的使用方式。

### 侵入式实现

在下面的实现中，MessageHandler 类和 Factory 类属于 framework 内容，这两个类组成了生成实例的框架。

framework 内容中的 MessageHandler 类作为表示"产品"(Product)的类，在该类中仅声明方法(这里是 Print)，而方法的实现则被交给了它的子类 MessageOneHandler 和 MessageTwoHandler 负责。

framework 内容中的 Factory 类声明并实现了 Register 和 CreateObject 方法，所以这里的 Factory 既属于框架内容，也负责了实际的处理。

[简单示例](intrusive.cpp)

当然，开发者这里也可以使用 Template Method 模式，在 Factory 类中只声明方法，而将具体的处理交给相应的子类负责。在下面的实现中，因为是调用不同的子类工厂类来创建，所以可以省略掉 Register 方法的实现，同时不用再为 CreateObject 方法传入标识符。具体如下:

[创建产品交由子类工厂的实现示例](intrusive_creator.cpp)

不过这种方法我不太喜欢。

如果需要向派生类中传入参数(比如上下文指针)，可以进行简单的修改。

[在简单示例基础上的带参数示例](intrusive_with_paras.cpp)

在上面的实现中，由于每次添加新的消息都需要对工厂类中的注册函数进入追加，所以这种实现是侵入式的。

### 模板实现

可以利用模板进行非侵入实现。

[模板实现实例](template.cpp)

如果需要向派生类中传入参数(比如上下文指针)，可以进行简单的修改。

[带可变参数的模板实现示例](factory.h)

### 工厂保存对象

工厂在创建对象的同时，也顺便可以对这些对象进行管理。在上面简单示例的程序基础上稍作改动。

[利用工厂管理对象](intrusive_store.cpp)

可以看到，对比之下就是加了一个数组存储。
